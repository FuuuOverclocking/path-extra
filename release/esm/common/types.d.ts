/// <reference types="node" />
import type nodefs from 'fs';
import type { IFs as memfs } from 'memfs';
import type fsExtra from 'fs-extra';
import type { PathNice } from '../platform/path-nice.js';
import type { PathNicePosix } from '../posix/path-nice-posix.js';
import type { PathNiceWin32 } from '../win32/path-nice-win32.js';
import type { Join, PathToString } from '../posix/type-gymnastics.js';
export declare type FileSystem = typeof nodefs | typeof fsExtra | memfs;
export interface Path extends PlatformPath {
    /**
     * Get a new instance of PathNice.
     *
     * A PathNice instance is a wrapper of the raw path string, so that the path
     * can be easily used to generate additional paths or manipulate files.
     *
     * For details, refer to [docs of PathNice](https://fuuuoverclocking.github.io/path-nice/classes/PathNice.html).
     *
     * @param paths in most case, only one path should be given; if multiple, join them
     * together; if zero, the path will be '.'
     *
     * @example
     *
     * Get a instance:
     *
     * ```ts
     * $ let src: PathNice = path('./src')
     * ```
     *
     * Get the raw path string:
     *
     * ```ts
     * $ src.raw
     * './src'
     * ```
     *
     * Use `src` to generate another path:
     *
     * ```ts
     * $ src.join('index.ts')
     * PathNice { raw: 'src/index.ts' }  // on POSIX
     * PathNice { raw: 'src\\index.ts' } // on Windows
     * ```
     *
     * Use `src` to write a file:
     *
     * ```ts
     * $ src.join('index.ts').writeFile('export default 42;')
     * Promise { <pending> ... }
     * ```
     */
    (...paths: Array<string | PathNice>): PathNice;
    /**
     * Posix specific pathing.
     */
    readonly posix: PathPosix;
    /**
     * Windows specific pathing.
     */
    readonly win32: PathWin32;
    readonly PathNice: typeof PathNice;
    readonly PathNicePosix: typeof PathNicePosix;
    readonly PathNiceWin32: typeof PathNiceWin32;
}
export interface PathPosix extends PlatformPath {
    /**
     * Get a new instance of PathNicePosix.
     *
     * @param paths the path string
     */
    <P extends Array<string | PathNicePosix<string>>>(...paths: P): PathPosixReturnType<P>;
    bindFS(fs: FileSystem): PathPosix;
    /**
     * Posix specific pathing.
     */
    readonly posix: PathPosix;
    /**
     * Windows specific pathing.
     */
    readonly win32: PathWin32;
    readonly PathNice: typeof PathNice;
    readonly PathNicePosix: typeof PathNicePosix;
    readonly PathNiceWin32: typeof PathNiceWin32;
}
declare type PathPosixReturnType<P extends Array<string | PathNicePosix<string>>> = P extends [] ? PathNicePosix<'.'> : P extends [infer A extends string | PathNicePosix<string>] ? PathNicePosix<PathToString<A>> : PathNicePosix<Join<P>>;
export interface PathWin32 extends PlatformPath {
    /**
     * Get a new instance of PathNiceWin32.
     *
     * @param str the path string
     * @param fs you can replace the original fs with something like memfs that has
     *           a file system API.
     */
    <P extends string>(str: P, fs?: FileSystem): PathNiceWin32<P>;
    bindFS(fs: FileSystem): PathWin32;
    /**
     * Posix specific pathing.
     */
    readonly posix: PathPosix;
    /**
     * Windows specific pathing.
     */
    readonly win32: PathWin32;
    readonly PathNice: typeof PathNice;
    readonly PathNicePosix: typeof PathNicePosix;
    readonly PathNiceWin32: typeof PathNiceWin32;
}
/**
 * A parsed path object generated by path.parse() or consumed by path.format().
 */
export interface ParsedPath {
    /**
     * The root of the path such as '/' or 'c:\\'
     */
    root: string;
    /**
     * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'
     */
    dir: string;
    /**
     * The file name including extension (if any) such as 'index.html'
     */
    base: string;
    /**
     * The file extension (if any) such as '.html'
     */
    ext: string;
    /**
     * The file name without extension (if any) such as 'index'
     */
    name: string;
}
export interface FormatInputPathObject {
    /**
     * The root of the path such as '/' or 'c:\\'
     */
    root?: string | undefined;
    /**
     * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'
     */
    dir?: string | undefined;
    /**
     * The file name including extension (if any) such as 'index.html'
     */
    base?: string | undefined;
    /**
     * The file extension (if any) such as '.html'
     */
    ext?: string | undefined;
    /**
     * The file name without extension (if any) such as 'index'
     */
    name?: string | undefined;
}
export interface PlatformPath {
    /**
     * Normalize a string path, reducing '..' and '.' parts.
     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
     *
     * @param p string path to normalize.
     */
    normalize(p: string): string;
    /**
     * Join all arguments together and normalize the resulting path.
     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
     *
     * @param paths paths to join.
     */
    join(...paths: string[]): string;
    /**
     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.
     *
     * Starting from leftmost {from} parameter, resolves {to} to an absolute path.
     *
     * If {to} isn't already absolute, {from} arguments are prepended in right to left order,
     * until an absolute path is found. If after using all {from} paths still no absolute path is found,
     * the current working directory is used as well. The resulting path is normalized,
     * and trailing slashes are removed unless the path gets resolved to the root directory.
     *
     * @param pathSegments string paths to join.  Non-string arguments are ignored.
     */
    resolve(...pathSegments: string[]): string;
    /**
     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
     *
     * @param path path to test.
     */
    isAbsolute(p: string): boolean;
    /**
     * Solve the relative path from {from} to {to}.
     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
     */
    relative(from: string, to: string): string;
    /**
     * Return the directory name of a path. Similar to the Unix dirname command.
     *
     * @param p the path to evaluate.
     */
    dirname(p: string): string;
    /**
     * Return the last portion of a path. Similar to the Unix basename command.
     * Often used to extract the file name from a fully qualified path.
     *
     * @param p the path to evaluate.
     * @param ext optionally, an extension to remove from the result.
     */
    basename(p: string, ext?: string): string;
    /**
     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
     *
     * @param p the path to evaluate.
     */
    extname(p: string): string;
    /**
     * The platform-specific file separator. '\\' or '/'.
     */
    readonly sep: string;
    /**
     * The platform-specific file delimiter. ';' or ':'.
     */
    readonly delimiter: string;
    /**
     * Returns an object from a path string - the opposite of format().
     *
     * @param pathString path to evaluate.
     */
    parse(p: string): ParsedPath;
    /**
     * Returns a path string from an object - the opposite of parse().
     *
     * @param pathString path to evaluate.
     */
    format(pP: FormatInputPathObject): string;
    /**
     * On Windows systems only, returns an equivalent namespace-prefixed path for the given path.
     * If path is not a string, path will be returned without modifications.
     * This method is meaningful only on Windows system.
     * On POSIX systems, the method is non-operational and always returns path without modifications.
     */
    toNamespacedPath(path: string): string;
    /**
     * Posix specific pathing.
     * Same as parent object on posix.
     */
    readonly posix: PlatformPath;
    /**
     * Windows specific pathing.
     * Same as parent object on windows
     */
    readonly win32: PlatformPath;
}
export {};
